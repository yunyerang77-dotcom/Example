<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹 뷰어 - 책 형태 텍스트 뷰어</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* 입력 섹션 스타일 */
        .input-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .input-section h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2.5rem;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .input-group textarea {
            flex: 1;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s ease;
        }

        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* 뷰어 섹션 스타일 */
        .viewer-section {
            display: none;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .viewer-section.active {
            display: block;
        }

        /* 책 레이아웃 컨테이너 */
        .book-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin: 20px 0;
            perspective: 1000px;
        }

        /* 개별 페이지 스타일 */
        .page {
            width: 400px;
            min-height: 600px;
            background: white;
            border-radius: 8px;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.1),
                0 8px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            padding: 40px;
            position: relative;
            transition: transform 0.3s ease;
        }

        /* 책의 중앙 바인딩 효과 */
        .page::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, #ddd, #bbb, #ddd);
        }

        .page.right::before {
            right: 0;
            left: auto;
        }

        /* 페이지 내용 스타일 */
        .page-content {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #2c3e50;
            text-align: justify;
            hyphens: auto;
        }

        .page-content h1 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .page-content h2 {
            font-size: 1.4rem;
            margin: 20px 0 15px 0;
            color: #34495e;
        }

        .page-content p {
            margin-bottom: 15px;
            text-indent: 1.5em;
        }

        /* 네비게이션 컨트롤 */
        .navigation {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
        }

        .nav-btn {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .nav-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .page-info {
            background: white;
            padding: 10px 20px;
            border-radius: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-weight: bold;
            color: #2c3e50;
        }

        /* 페이지 전환 애니메이션 */
        .page-transition {
            animation: pageFlip 0.5s ease-in-out;
        }

        @keyframes pageFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(-10deg); }
            100% { transform: rotateY(0deg); }
        }

        /* 반응형 디자인 */
        @media (max-width: 900px) {
            .book-container {
                flex-direction: column;
                align-items: center;
            }
            
            .page {
                width: 100%;
                max-width: 400px;
            }
        }

        @media (max-width: 600px) {
            .input-group {
                flex-direction: column;
            }
            
            .page {
                padding: 20px;
                min-height: 400px;
            }
            
            .page-content {
                font-size: 1rem;
            }
        }

        /* 로딩 애니메이션 */
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 입력 섹션 -->
        <div class="input-section" id="inputSection">
            <h1>📖 웹 뷰어</h1>
            <div class="input-group">
                <textarea id="textInput" placeholder="여기에 표시할 텍스트를 입력하세요...&#10;&#10;예시:&#10;제1장 시작&#10;&#10;이것은 웹 뷰어의 예시 텍스트입니다. 긴 텍스트를 입력하면 자동으로 페이지가 나뉘어 표시됩니다.&#10;&#10;제2장 계속&#10;&#10;각 페이지는 책의 형태로 표시되며, 좌우 화살표 버튼을 사용하여 페이지를 넘길 수 있습니다."></textarea>
                <button class="btn" id="viewBtn">보기</button>
            </div>
        </div>

        <!-- 로딩 섹션 -->
        <div class="loading" id="loadingSection">
            <div class="spinner"></div>
            <p>페이지를 준비하고 있습니다...</p>
        </div>

        <!-- 뷰어 섹션 -->
        <div class="viewer-section" id="viewerSection">
            <div class="book-container">
                <div class="page left" id="leftPage">
                    <div class="page-content" id="leftPageContent"></div>
                </div>
                <div class="page right" id="rightPage">
                    <div class="page-content" id="rightPageContent"></div>
                </div>
            </div>
            
            <div class="navigation">
                <button class="nav-btn" id="prevBtn" disabled>‹</button>
                <div class="page-info" id="pageInfo">1 / 1</div>
                <button class="nav-btn" id="nextBtn" disabled>›</button>
            </div>
        </div>
    </div>

    <script>
        // DOM 요소들
        const inputSection = document.getElementById('inputSection');
        const loadingSection = document.getElementById('loadingSection');
        const viewerSection = document.getElementById('viewerSection');
        const textInput = document.getElementById('textInput');
        const viewBtn = document.getElementById('viewBtn');
        const leftPageContent = document.getElementById('leftPageContent');
        const rightPageContent = document.getElementById('rightPageContent');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const pageInfo = document.getElementById('pageInfo');

        // 전역 변수
        let pages = []; // 페이지별 텍스트를 저장하는 배열
        let currentPageIndex = 0; // 현재 페이지 인덱스

        // 페이지당 최대 글자 수 (실제로는 더 정교한 계산이 필요하지만 간단히 구현)
        const MAX_CHARS_PER_PAGE = 2000;

        /**
         * 텍스트를 페이지 단위로 나누는 함수
         * @param {string} text - 나눌 텍스트
         * @returns {Array} 페이지별 텍스트 배열
         */
        function splitTextIntoPages(text) {
            if (!text.trim()) {
                return ['텍스트를 입력해주세요.'];
            }

            const paragraphs = text.split('\n\n'); // 빈 줄로 문단 구분
            const pages = [];
            let currentPage = '';

            for (let paragraph of paragraphs) {
                // 문단이 너무 길면 문장 단위로 나누기
                if (paragraph.length > MAX_CHARS_PER_PAGE) {
                    const sentences = paragraph.split(/[.!?]+/);
                    let currentSentence = '';
                    
                    for (let sentence of sentences) {
                        if (sentence.trim()) {
                            sentence = sentence.trim() + '.';
                            
                            if ((currentPage + currentSentence + sentence).length > MAX_CHARS_PER_PAGE) {
                                if (currentPage.trim()) {
                                    pages.push(currentPage.trim());
                                    currentPage = '';
                                }
                                currentPage = currentSentence + sentence + '\n\n';
                                currentSentence = '';
                            } else {
                                currentSentence += sentence + ' ';
                            }
                        }
                    }
                    
                    if (currentSentence.trim()) {
                        currentPage += currentSentence + '\n\n';
                    }
                } else {
                    // 문단이 페이지에 들어갈 수 있는지 확인
                    if ((currentPage + paragraph).length > MAX_CHARS_PER_PAGE) {
                        if (currentPage.trim()) {
                            pages.push(currentPage.trim());
                        }
                        currentPage = paragraph + '\n\n';
                    } else {
                        currentPage += paragraph + '\n\n';
                    }
                }
            }

            // 마지막 페이지 추가
            if (currentPage.trim()) {
                pages.push(currentPage.trim());
            }

            return pages.length > 0 ? pages : ['텍스트를 입력해주세요.'];
        }

        /**
         * 페이지를 표시하는 함수
         * @param {number} pageIndex - 표시할 페이지 인덱스
         */
        function displayPage(pageIndex) {
            if (pageIndex < 0 || pageIndex >= pages.length) return;

            const leftPageIndex = pageIndex * 2;
            const rightPageIndex = pageIndex * 2 + 1;

            // 좌측 페이지 설정
            if (leftPageIndex < pages.length) {
                leftPageContent.innerHTML = formatPageContent(pages[leftPageIndex]);
            } else {
                leftPageContent.innerHTML = '';
            }

            // 우측 페이지 설정
            if (rightPageIndex < pages.length) {
                rightPageContent.innerHTML = formatPageContent(pages[rightPageIndex]);
            } else {
                rightPageContent.innerHTML = '';
            }

            // 페이지 정보 업데이트
            const totalPages = Math.ceil(pages.length / 2);
            pageInfo.textContent = `${pageIndex + 1} / ${totalPages}`;

            // 네비게이션 버튼 상태 업데이트
            prevBtn.disabled = pageIndex === 0;
            nextBtn.disabled = pageIndex >= totalPages - 1;

            // 페이지 전환 애니메이션
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('page-transition');
                setTimeout(() => {
                    page.classList.remove('page-transition');
                }, 500);
            });
        }

        /**
         * 페이지 내용을 HTML로 포맷팅하는 함수
         * @param {string} content - 페이지 내용
         * @returns {string} HTML 포맷된 내용
         */
        function formatPageContent(content) {
            if (!content) return '';

            // 제목 감지 (숫자로 시작하는 줄)
            let formatted = content.replace(/^(\d+[장절]?\.?\s+.+)$/gm, '<h1>$1</h1>');
            
            // 부제목 감지 (##로 시작하는 줄)
            formatted = formatted.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            
            // 문단을 p 태그로 감싸기
            formatted = formatted.replace(/\n\n/g, '</p><p>');
            formatted = '<p>' + formatted + '</p>';
            
            // 빈 p 태그 제거
            formatted = formatted.replace(/<p><\/p>/g, '');
            formatted = formatted.replace(/<p>\s*<\/p>/g, '');

            return formatted;
        }

        /**
         * 뷰어를 초기화하는 함수
         */
        function initializeViewer() {
            const text = textInput.value.trim();
            
            if (!text) {
                alert('텍스트를 입력해주세요.');
                return;
            }

            // 로딩 표시
            inputSection.style.display = 'none';
            loadingSection.classList.add('active');
            viewerSection.classList.remove('active');

            // 비동기 처리로 부드러운 전환
            setTimeout(() => {
                // 텍스트를 페이지로 나누기
                pages = splitTextIntoPages(text);
                currentPageIndex = 0;

                // 첫 페이지 표시
                displayPage(currentPageIndex);

                // 뷰어 표시
                loadingSection.classList.remove('active');
                viewerSection.classList.add('active');
            }, 500);
        }

        /**
         * 이전 페이지로 이동
         */
        function goToPreviousPage() {
            if (currentPageIndex > 0) {
                currentPageIndex--;
                displayPage(currentPageIndex);
            }
        }

        /**
         * 다음 페이지로 이동
         */
        function goToNextPage() {
            const totalPages = Math.ceil(pages.length / 2);
            if (currentPageIndex < totalPages - 1) {
                currentPageIndex++;
                displayPage(currentPageIndex);
            }
        }

        /**
         * 입력 섹션으로 돌아가기
         */
        function backToInput() {
            viewerSection.classList.remove('active');
            inputSection.style.display = 'block';
        }

        // 이벤트 리스너 등록
        viewBtn.addEventListener('click', initializeViewer);
        prevBtn.addEventListener('click', goToPreviousPage);
        nextBtn.addEventListener('click', goToNextPage);

        // 키보드 단축키
        document.addEventListener('keydown', (e) => {
            if (viewerSection.classList.contains('active')) {
                if (e.key === 'ArrowLeft') {
                    goToPreviousPage();
                } else if (e.key === 'ArrowRight') {
                    goToNextPage();
                } else if (e.key === 'Escape') {
                    backToInput();
                }
            }
        });

        // Enter + Ctrl로 뷰어 시작
        textInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                initializeViewer();
            }
        });

        // 초기화
        function init() {
            // 예시 텍스트 설정
            const exampleText = `제1장 웹 뷰어의 시작

이것은 웹 뷰어의 예시 텍스트입니다. 긴 텍스트를 입력하면 자동으로 페이지가 나뉘어 표시됩니다.

웹 뷰어는 사용자가 입력한 텍스트를 책의 형태로 보여주는 도구입니다. 각 페이지는 마치 실제 책처럼 보이도록 디자인되었습니다.

제2장 기능 소개

## 주요 기능

이 뷰어는 다음과 같은 기능을 제공합니다:

1. 텍스트 입력 및 자동 페이지 분할
2. 좌우 화살표를 통한 페이지 네비게이션
3. 키보드 단축키 지원 (좌우 화살표, ESC)
4. 반응형 디자인으로 다양한 화면 크기 지원

## 사용법

텍스트를 입력하고 "보기" 버튼을 클릭하면 책 형태로 표시됩니다. 좌우 화살표 버튼이나 키보드의 화살표 키를 사용하여 페이지를 넘길 수 있습니다.

제3장 마무리

이제 여러분만의 텍스트를 입력하여 웹 뷰어를 사용해보세요. 긴 문서도 자동으로 페이지가 나뉘어 편리하게 읽을 수 있습니다.

좋은 하루 되세요!`;

            textInput.value = exampleText;
        }

        // 페이지 로드 시 초기화
        init();
    </script>
</body>
</html>

